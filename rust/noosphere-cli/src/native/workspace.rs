use anyhow::{anyhow, Result};
use noosphere::authority::restore_ed25519_key;
use noosphere_storage::{
    db::SphereDb,
    native::{NativeStorageInit, NativeStorageProvider, NativeStore},
};
use path_absolutize::Absolutize;
use std::{collections::BTreeMap, path::PathBuf};
use tokio::fs;
use ucan::Ucan;
use ucan_key_support::ed25519::Ed25519KeyMaterial;

const NOOSPHERE_DIRECTORY: &str = ".noosphere";
const SPHERE_DIRECTORY: &str = ".sphere";
const BLOCKS_DIRECTORY: &str = "blocks";
const KEYS_DIRECTORY: &str = "keys";
const AUTHORIZATION_FILE: &str = "AUTHORIZATION";
const KEY_FILE: &str = "KEY";
const IDENTITY_FILE: &str = "IDENTITY";

/// A utility for discovering and initializing the well-known paths for a
/// working copy of a sphere and relevant global Noosphere configuration
#[derive(Clone, Debug)]
pub struct Workspace {
    root: PathBuf,
    sphere: PathBuf,
    blocks: PathBuf,
    noosphere: PathBuf,
    keys: PathBuf,
    authorization: PathBuf,
    key: PathBuf,
    identity: PathBuf,
}

impl Workspace {
    /// The root directory containing the working copy of sphere files on
    /// disk, as well as the local sphere data
    pub fn root_path(&self) -> &PathBuf {
        &self.root
    }

    /// The path to the sphere data folder within the working file tree
    pub fn sphere_path(&self) -> &PathBuf {
        &self.sphere
    }

    /// The path to the block storage database within the working file tree
    pub fn blocks_path(&self) -> &PathBuf {
        &self.blocks
    }

    /// The path to the folder that contains global Noosphere configuration
    /// and keys generated by the user
    pub fn noosphere_path(&self) -> &PathBuf {
        &self.noosphere
    }

    /// The path to the folder containing user-generated keys when there is
    /// no secure option for generating them available
    pub fn keys_path(&self) -> &PathBuf {
        &self.keys
    }

    /// Path to the local authorization (the granted UCAN) for the key that
    /// is authorized to work on the sphere
    pub fn authorization_path(&self) -> &PathBuf {
        &self.authorization
    }

    pub fn key_path(&self) -> &PathBuf {
        &self.key
    }

    pub fn identity_path(&self) -> &PathBuf {
        &self.identity
    }

    /// Attempts to read the locally stored authorization that enables the key
    /// to operate on this sphere, and returns it as a UCAN
    pub async fn get_local_authorization(&self) -> Result<Ucan> {
        self.expect_local_directories()?;

        let authorization_jwt = fs::read_to_string(&self.authorization).await?;
        let ucan = Ucan::try_from_token_string(&authorization_jwt)?;

        Ok(ucan)
    }

    pub async fn get_local_db(&self) -> Result<SphereDb<NativeStore>> {
        self.expect_local_directories()?;

        let storage_provider =
            NativeStorageProvider::new(NativeStorageInit::Path(self.blocks_path().clone()))?;
        SphereDb::new(&storage_provider).await
    }

    pub async fn get_local_key(&self) -> Result<Ed25519KeyMaterial> {
        self.expect_global_directories()?;
        self.expect_local_directories()?;

        let local_key_did = fs::read_to_string(&self.key).await?;
        let keys = self.get_all_keys().await?;

        for (key, did) in keys {
            if did == local_key_did {
                let private_key_mnemonic = self.get_key_mnemonic(&key).await?;
                return restore_ed25519_key(&private_key_mnemonic);
            }
        }

        Err(anyhow!(
            "Could not resolve private key material for {:?}",
            local_key_did
        ))
    }

    pub async fn get_local_identity(&self) -> Result<String> {
        self.expect_local_directories()?;

        Ok(fs::read_to_string(&self.identity).await?)
    }

    /// Look up the DID for the key by its name
    pub async fn get_key_did(&self, name: &str) -> Result<String> {
        Ok(fs::read_to_string(self.keys.join(name).with_extension("public")).await?)
    }

    pub async fn get_key_mnemonic(&self, name: &str) -> Result<String> {
        Ok(fs::read_to_string(self.keys.join(name).with_extension("private")).await?)
    }

    /// Returns true if there are no files in the configured root path
    pub async fn is_root_empty(&self) -> Result<bool> {
        let mut directory = fs::read_dir(&self.root).await?;

        Ok(if let Some(_) = directory.next_entry().await? {
            false
        } else {
            true
        })
    }

    /// Reads all the available keys and returns a map of their names to their
    /// DIDs
    pub async fn get_all_keys(&self) -> Result<BTreeMap<String, String>> {
        self.expect_global_directories()?;

        let mut key_names = BTreeMap::<String, String>::new();
        let mut directory = fs::read_dir(&self.keys).await?;

        while let Some(entry) = directory.next_entry().await? {
            let key_path = entry.path();
            let key_name = key_path.file_stem().map(|stem| stem.to_str());
            let extension = key_path.extension().map(|extension| extension.to_str());

            match (key_name, extension) {
                (Some(Some(key_name)), Some(Some("public"))) => {
                    let did = self.get_key_did(key_name).await?;
                    key_names.insert(key_name.to_string(), did);
                }
                _ => continue,
            };
        }

        Ok(key_names)
    }

    /// If there is only one key to choose from, returns its name. Otherwise
    /// returns an error result.
    pub async fn unambiguous_default_key_name(&self) -> Result<String> {
        if self.expect_global_directories().is_ok() {
            let keys = self.get_all_keys().await?;

            if keys.len() > 1 {
                let key_names = keys
                    .into_iter()
                    .map(|(name, _)| name)
                    .collect::<Vec<String>>()
                    .join("\n");
                return Err(anyhow!(
                    r#"There is more than one key; you should specify a key to use by name
The available keys are:

{}"#,
                    key_names
                ));
            } else if let Some((key_name, _)) = keys.iter().next() {
                return Ok(key_name.clone());
            }
        }

        Err(anyhow!("No keys found; have you created any yet?"))
    }

    /// Asserts that all related directories for the suggested working file
    /// tree root are present
    pub fn expect_local_directories(&self) -> Result<()> {
        if !self.root.is_dir() {
            return Err(anyhow!(
                "Configured sphere root {:?} is not a directory!",
                self.root
            ));
        }

        if !self.sphere.is_dir() {
            return Err(anyhow!(
                "The {:?} folder within {:?} is missing or corrupted",
                SPHERE_DIRECTORY,
                self.root
            ));
        }

        Ok(())
    }

    /// Asserts that the global Noosphere directories are present
    pub fn expect_global_directories(&self) -> Result<()> {
        if !self.noosphere.is_dir() || !self.keys.is_dir() {
            return Err(anyhow!(
                "The Noosphere config directory ({:?}) is missing or corrupted",
                self.noosphere
            ));
        }

        Ok(())
    }

    /// Creates all the directories needed to start rendering a sphere in the
    /// configured working file tree root
    pub async fn initialize_local_directories(&self) -> Result<()> {
        let mut root = self.root.clone();

        while let Some(parent) = root.clone().parent() {
            root = parent.to_path_buf();
            let working_paths = Workspace::new(&root)?;
            if let Ok(_) = working_paths.expect_local_directories() {
                return Err(anyhow!(
                    r#"Tried to initialize sphere directories in {:?}
...but a sphere is already initialized in {:?}
Unexpected things will happen if you try to nest spheres this way!"#,
                    self.root,
                    parent
                ))?;
            }
        }

        fs::create_dir_all(&self.sphere).await?;

        Ok(())
    }

    /// Creates the global Noosphere config and keys directories
    pub async fn initialize_global_directories(&self) -> Result<()> {
        fs::create_dir_all(&self.keys).await?;

        Ok(())
    }

    pub fn new(root: &PathBuf) -> Result<Self> {
        if !root.is_absolute() {
            return Err(anyhow!("Ambiguous path to sphere root: {:?}", root));
        }

        let root = root.absolutize()?.to_path_buf();
        let sphere = root.join(SPHERE_DIRECTORY);
        let blocks = sphere.join(BLOCKS_DIRECTORY);
        let authorization = sphere.join(AUTHORIZATION_FILE);
        let key = sphere.join(KEY_FILE);
        let identity = sphere.join(IDENTITY_FILE);
        let noosphere = home::home_dir()
            .ok_or_else(|| {
                anyhow!(
                    "Could not discover home directory for {}",
                    whoami::username()
                )
            })?
            .join(NOOSPHERE_DIRECTORY);
        let keys = noosphere.join(KEYS_DIRECTORY);

        Ok(Workspace {
            root,
            sphere,
            blocks,
            authorization,
            key,
            identity,
            noosphere,
            keys,
        })
    }
}
